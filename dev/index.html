<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · YaoLang.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">YaoLang.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Introduction-1"><span>Introduction</span></a></li><li><a class="tocitem" href="#Why?-1"><span>Why?</span></a></li><li><a class="tocitem" href="#API-References-1"><span>API References</span></a></li><li><a class="tocitem" href="#Compiler-API-References-1"><span>Compiler API References</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuantumBFS/YaoLang.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Introduction-1"><a class="docs-heading-anchor" href="#Introduction-1">Introduction</a><a class="docs-heading-anchor-permalink" href="#Introduction-1" title="Permalink"></a></h2><p>YaoLang is a domain specific language (DSL) built based on Julia builtin expression with extended semantic on quantum control, measure and position. Its (extended) syntax is very simple:</p><h3 id="Semantics-1"><a class="docs-heading-anchor" href="#Semantics-1">Semantics</a><a class="docs-heading-anchor-permalink" href="#Semantics-1" title="Permalink"></a></h3><p>The semantic of YaoLang tries to make use of Julia semantic as much as possible so you don&#39;t feel this is not Julian. But since the quantum circuit has some special semantic that Julia expression cannot express directly, the semantic of Julia expression is extended in YaoLang.</p><p>The point of this new IR is it make use of Julia native control flow directly instead of unroll the loop and conditions into a Julia type, such as <code>Chain</code>, <code>Kron</code>, <code>ConditionBlock</code> in QBIR, which improves the performance and provide possibility of further compiler optimization by analysis done on quantum circuit and classical control flows.</p><h4 id="Gate-Position-1"><a class="docs-heading-anchor" href="#Gate-Position-1">Gate Position</a><a class="docs-heading-anchor-permalink" href="#Gate-Position-1" title="Permalink"></a></h4><p>gate positions are specific with <code>=&gt;</code> at each line, the <code>=&gt;</code> operator inside function calls will not be parsed, e.g</p><pre><code class="language-jl">1 =&gt; H # apply Hadamard gate on the 1st qubit
foo(1=&gt;H) # it means normal Julia pair
1=&gt;foo(x, y, z) # it will parse foo(x, y, z) as a quantum gate/circuit, but will error later if type inference finds they are not.</code></pre><p>all the gate or circuit&#39;s position should be specified by its complete locations, e.g</p><pre><code class="language-jl">1:n =&gt; qft(n) # right
1 =&gt; qft(n) # wrong</code></pre><p>but single qubit gates can use multi-location argument to represent repeated locations, e.g</p><pre><code class="language-jl">1:n =&gt; H # apply H on 1:n locations</code></pre><h4 id="Control-1"><a class="docs-heading-anchor" href="#Control-1">Control</a><a class="docs-heading-anchor-permalink" href="#Control-1" title="Permalink"></a></h4><p><a href="#YaoLang.Compiler.@ctrl"><code>@ctrl</code></a> is parsed as a keyword (means you cannot overload it) in each program, like QBIR, its first argument is the control location with signs as control configurations and the second argument is a normal gate position argument introduce above.</p><h4 id="Measure-1"><a class="docs-heading-anchor" href="#Measure-1">Measure</a><a class="docs-heading-anchor-permalink" href="#Measure-1" title="Permalink"></a></h4><p><a href="#YaoLang.Compiler.@measure"><code>@measure</code></a> is another reserved special function parsed that has specific semantic in the IR (measure the locations passed to it).</p><h3 id="Usage-1"><a class="docs-heading-anchor" href="#Usage-1">Usage</a><a class="docs-heading-anchor-permalink" href="#Usage-1" title="Permalink"></a></h3><p>using it is pretty simple, just use <a href="#YaoLang.Compiler.@device"><code>@device</code></a> macro to annotate a &quot;device&quot; function, like CUDA programming, this device function should not return anything but <code>nothing</code>.</p><p>The compiler will compile this function definition to a generic circuit <code>Circuit</code> with the same name. A generic circuit is a generic quantum program that can be overload with different Julia types, e.g</p><pre><code class="language-jl">@device function qft(n::Int)
    1 =&gt; H
    for k in 2:n
        @ctrl k 1=&gt;shift(2π/2^k)
    end

    if n &gt; 1
        2:n =&gt; qft(n-1)
    end
end</code></pre><p><strong>There is no need to worry about global position</strong>: everything can be defined locally and we will infer the correct global location later either in compile time or runtime.</p><p>note: all the quantum gates should be annotate with its corresponding locations, or the compiler will not treat it as a quantum gate but instead of the original Julia expression.</p><h2 id="Why?-1"><a class="docs-heading-anchor" href="#Why?-1">Why?</a><a class="docs-heading-anchor-permalink" href="#Why?-1" title="Permalink"></a></h2><p>There are a few reasons that we need a fully compiled DSL now.</p><h3 id=".-Extensibility-1"><a class="docs-heading-anchor" href="#.-Extensibility-1">1. Extensibility</a><a class="docs-heading-anchor-permalink" href="#.-Extensibility-1" title="Permalink"></a></h3><p>Things in YaoBlocks like</p><pre><code class="language-none">function apply!(r::AbstractRegister, pb::PutBlock{N}) where {N}
    _check_size(r, pb)
    instruct!(r, mat_matchreg(r, pb.content), pb.locs)
    return r
end

# specialization
for G in [:X, :Y, :Z, :T, :S, :Sdag, :Tdag]
    GT = Expr(:(.), :ConstGate, QuoteNode(Symbol(G, :Gate)))
    @eval function apply!(r::AbstractRegister, pb::PutBlock{N,C,&lt;:$GT}) where {N,C}
        _check_size(r, pb)
        instruct!(r, Val($(QuoteNode(G))), pb.locs)
        return r
    end
end</code></pre><p>cannot be easily extended without define new dispatch on specialized instruction. Similarly, as long as there is a new instruction in low level, one need to redefine the dispatch in <code>YaoBlocks</code> however this is not necessary!</p><h3 id=".-Work-with-classical-computers-1"><a class="docs-heading-anchor" href="#.-Work-with-classical-computers-1">2. Work with classical computers</a><a class="docs-heading-anchor-permalink" href="#.-Work-with-classical-computers-1" title="Permalink"></a></h3><p>Programs defined in such way are just &quot;normal&quot; Julia programs, but quantum devices can be used as accelerator in a similar way comparing to GPU as an optimization.</p><h3 id=".-More-elegant-and-better-performance-1"><a class="docs-heading-anchor" href="#.-More-elegant-and-better-performance-1">3. More elegant and better performance</a><a class="docs-heading-anchor-permalink" href="#.-More-elegant-and-better-performance-1" title="Permalink"></a></h3><p>In YaoBlocks, a large quantum circuit can easily lost its structure if it is controlled, unless the programmer specialize the control block manually. Now we can map local locations into its callee location using the brand new API, thus anything in theory is composable can be executed in such way.</p><h2 id="API-References-1"><a class="docs-heading-anchor" href="#API-References-1">API References</a><a class="docs-heading-anchor-permalink" href="#API-References-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="YaoLang.H" href="#YaoLang.H"><code>YaoLang.H</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">H</code></pre><p>The Hadamard gate.</p><p><strong>Definition</strong></p><div>\[\frac{1}{\sqrt{2}} \begin{pmatrix}
1 &amp; 1\
1 &amp; -1
\end{pmatrix}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Rx" href="#YaoLang.Rx"><code>YaoLang.Rx</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">Rx(theta::Real)</code></pre><p>Return a rotation gate on X axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Ry" href="#YaoLang.Ry"><code>YaoLang.Ry</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">Ry(theta::Real)</code></pre><p>Return a rotation gate on Y axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Rz" href="#YaoLang.Rz"><code>YaoLang.Rz</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">Rz(theta::Real)</code></pre><p>Return a rotation gate on Z axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.T" href="#YaoLang.T"><code>YaoLang.T</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">T</code></pre><p>The T gate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.X" href="#YaoLang.X"><code>YaoLang.X</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">X</code></pre><p>The Pauli X gate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Y" href="#YaoLang.Y"><code>YaoLang.Y</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">Y</code></pre><p>The Pauli Y gate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Z" href="#YaoLang.Z"><code>YaoLang.Z</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">Z</code></pre><p>The Pauli Z gate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.phase" href="#YaoLang.phase"><code>YaoLang.phase</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">phase(theta)</code></pre><p>Global phase gate.</p><p><strong>Definition</strong></p><div>\[exp(iθ) \mathbf{I}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.rot" href="#YaoLang.rot"><code>YaoLang.rot</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">rot(axis, θ::T, m::Int=size(axis, 1)) where {T &lt;: Real}</code></pre><p>General rotation gate, <code>axis</code> is the rotation axis, <code>θ</code> is the rotation angle. <code>m</code> is the size of rotation space, default is the size of rotation axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.shift" href="#YaoLang.shift"><code>YaoLang.shift</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">shift(θ::Real)</code></pre><p>Phase shift gate.</p><p><strong>Definition</strong></p><div>\[\begin{pmatrix}
1 &amp; 0\
0 &amp; e^(im θ)
\end{pmatrix}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.GenericCircuit" href="#YaoLang.GenericCircuit"><code>YaoLang.GenericCircuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GenericCircuit{name}</code></pre><p>Generic quantum circuit is the quantum counterpart of generic function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Locations" href="#YaoLang.Locations"><code>YaoLang.Locations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Locations &lt;: AbstractLocations</code></pre><p>Type to annotate locations in quantum circuit.</p><pre><code class="language-none">Locations(x)</code></pre><p>Create a <code>Locations</code> object from a raw location statement. Valid storage types are:</p><ul><li><code>Int</code>: single position</li><li><code>NTuple{N, Int}</code>: a list of locations</li><li><code>UnitRange{Int}</code>: contiguous locations</li></ul><p>Other types will be converted to the storage type via <code>Tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.merge_locations-Tuple{AbstractLocations,AbstractLocations,Vararg{AbstractLocations,N} where N}" href="#YaoLang.merge_locations-Tuple{AbstractLocations,AbstractLocations,Vararg{AbstractLocations,N} where N}"><code>YaoLang.merge_locations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge_locations(locations...)</code></pre><p>Construct a new <code>Locations</code> by merging two or more existing locations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><h2 id="Compiler-API-References-1"><a class="docs-heading-anchor" href="#Compiler-API-References-1">Compiler API References</a><a class="docs-heading-anchor-permalink" href="#Compiler-API-References-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.is_qasm_compatible-Tuple{YaoLang.Compiler.YaoIR}" href="#YaoLang.Compiler.is_qasm_compatible-Tuple{YaoLang.Compiler.YaoIR}"><code>YaoLang.Compiler.is_qasm_compatible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_qasm_compatible(ir)</code></pre><p>Check if the given expression is compatible with openQASM.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.is_quantum-Tuple{IRTools.Inner.Statement}" href="#YaoLang.Compiler.is_quantum-Tuple{IRTools.Inner.Statement}"><code>YaoLang.Compiler.is_quantum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_quantum(ex)</code></pre><p>Check if the given expression is a quantum statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.@code_yao-Tuple{Any}" href="#YaoLang.Compiler.@code_yao-Tuple{Any}"><code>YaoLang.Compiler.@code_yao</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@code_yao &lt;generic circuit call&gt;</code></pre><p>Evaluates the arguments to the function call, determines their types, and calls <code>code_yao</code> on the resulting expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.@ctrl" href="#YaoLang.Compiler.@ctrl"><code>YaoLang.Compiler.@ctrl</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@ctrl k &lt;gate location&gt;</code></pre><p>Keyword for controlled gates in quantum circuit. It must be used inside <code>@device</code>. See also <a href="#YaoLang.Compiler.@device"><code>@device</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.@device" href="#YaoLang.Compiler.@device"><code>YaoLang.Compiler.@device</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@device [options] &lt;generic circuit definition&gt;</code></pre><p>Entry for defining a generic quantum program. A generic quantum program is a function takes a set of classical arguments as input and return a quantum program that can be furthur compiled into pulses or other quantum instructions. The quantum program can return classical values from device if <code>return</code> statement is declared explicitly, or it always return nothing, and mutates the quantum register.</p><p><strong>Supported Semantics</strong></p><ul><li><a href="#YaoLang.Compiler.@ctrl"><code>@ctrl</code></a>: Keyword for controlled gates in quantum circuit.</li><li><a href="#YaoLang.Compiler.@measure"><code>@measure</code></a>: Keyword for measurement in quantum circuit.</li></ul><p>The function marked by <code>@device</code> can be multiple dispatched like other Julia function. The only difference is that it always returns a quantum circuit object that should be runable on quantum device by feeding it the location of qubits and the pointer to quantum register.</p><p><strong>Options</strong></p><ul><li><code>mode</code>, compilation mode, default is <code>:hybrid</code>, see <strong>Compilation Modes</strong> for details.</li><li><code>target</code>, compilation target, default is <code>:julia</code>, see <strong>Compilation Targets</strong> for details.</li></ul><p><strong>Compilation Modes</strong></p><ul><li><code>:hybrid</code>, default mode, allows arbitrary Julia code to work with quantum statements.</li><li><code>:pure</code>, all classical statements are disabled.</li><li><code>:qasm</code>, allows limited set of classical statements which is compatible to <a href="https://github.com/Qiskit/openqasm">openQASM</a></li></ul><p><strong>Compilation Targets</strong></p><ul><li><code>:julia</code>, default target, compiles the program to Julia program.</li><li><code>:qasm</code>, compiles the program to <a href="https://github.com/Qiskit/openqasm">openQASM</a>.</li></ul><p><strong>Example</strong></p><p>We can define a Quantum Fourier Transformation in the following recursive way</p><pre><code class="language-julia">@device function qft(n::Int)
    1 =&gt; H
    for k in 2:n
        @ctrl k 1=&gt;shift(2π/2^k)
    end

    if n &gt; 1
        2:n =&gt; qft(n-1)
    end
end</code></pre><p>This will give us a generic quantum circuit <code>qft</code> with 1 method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.@measure" href="#YaoLang.Compiler.@measure"><code>YaoLang.Compiler.@measure</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@measure &lt;location&gt; [operator] [configuration]</code></pre><p>Keyword for measurement in quantum circuit. It must be used inside <code>@device</code>. See also <a href="#YaoLang.Compiler.@device"><code>@device</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>&lt;location&gt;</code>: a valid <code>Locations</code> argument to specifiy where to measure the register</li><li><code>[operator]</code>: Optional, specifiy which operator to measure</li><li><code>[configuration]</code>: Optional, it can be either:<ul><li><code>remove=true</code> will remove the measured qubits</li><li><code>reset_to=&lt;bitstring&gt;</code> will reset the measured qubits to given bitstring</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.@primitive-Tuple{Any}" href="#YaoLang.Compiler.@primitive-Tuple{Any}"><code>YaoLang.Compiler.@primitive</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@primitive ex</code></pre><p>Define a primitive quantum instruction. <code>ex</code> can be a Symbol, if the corresponding instruction interface of <code>YaoAPI.instruct!</code> is implemented. Or <code>ex</code> can be an assignment statement for constant instructions. Or <code>ex</code> can be a function that returns corresponding matrix given a set of classical parameters.</p><p><strong>Example</strong></p><p>Since the instructions interface <code>YaoAPI.instruct!</code> of Pauli operators are defined, we can use</p><pre><code class="language-julia">@primitive X</code></pre><p>to declare a Pauli X primitive instruction.</p><p>Or we can also define a Hadamard primitive instruction via its matrix form</p><pre><code class="language-julia">@primitive H = [1 1;1 -1]/sqrt(2)</code></pre><p>For parameterized gates, such as phase shift gate, we can define it as</p><pre><code class="language-julia">@primitive shift(θ::Real) = Diagonal([1.0, exp(im * θ)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.generate_forward_stub-Tuple{Symbol,Any}" href="#YaoLang.Compiler.generate_forward_stub-Tuple{Symbol,Any}"><code>YaoLang.Compiler.generate_forward_stub</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_forward_stub(name::Symbol, op)</code></pre><p>Generate forward stub which forward primitive circuit to instruction interfaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.mark_quantum-Tuple{IRTools.Inner.IR}" href="#YaoLang.Compiler.mark_quantum-Tuple{IRTools.Inner.IR}"><code>YaoLang.Compiler.mark_quantum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mark_quantum(ir::IR)</code></pre><p>swap the statement tag with <code>:quantum</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoLang.Compiler.rm_annotations-Tuple{Any}" href="#YaoLang.Compiler.rm_annotations-Tuple{Any}"><code>YaoLang.Compiler.rm_annotations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rm_annotations(x)</code></pre><p>Remove type annotation of given expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/YaoLang.jl">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 7 June 2020 12:36">Sunday 7 June 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
